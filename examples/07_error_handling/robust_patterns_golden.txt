
==================================================
  Robust Error Handling Patterns
==================================================


============================================================
üîß Running in simulated mode (no API keys detected)
============================================================

To run this example with real API calls, set one of:
  export OPENAI_API_KEY='your-key-here'
  export ANTHROPIC_API_KEY='your-key-here'
  export GOOGLE_API_KEY='your-key-here'

Simulated output will demonstrate the expected behavior.
============================================================

==================================================
Example 1: Basic Error Handling
==================================================

Testing error handling:

Input: 'I love this product!'
‚úÖ Result: positive

Input: ''
‚ùå Error: Invalid input: text must be a non-empty string

Input: None
‚ùå Error: Invalid input: text must be a non-empty string

Input: 'This is okay I guess'
‚úÖ Result: neutral

==================================================
Example 2: Retry Mechanism
==================================================

Testing retry mechanism:
  Attempt 1 failed: Network timeout
  Retrying in 1.0s...
‚úÖ Success after 2 attempts: Bonjour le monde

==================================================
Example 3: Fallback Strategies
==================================================

Trying primary model: gpt-4
Primary model failed: Simulated primary model failure
Falling back to: gpt-3.5-turbo

Result: Buenos d√≠as
Model used: gpt-3.5-turbo
Fallback used: True

==================================================
Example 4: Input Validation
==================================================

Testing input validation:

Test 1: {'text': 'Hello world', 'language': 'English'}
‚úÖ Success
   Result: {'analysis': 'This English text contains common words and standard grammar.', 'text_length': 11, 'language': 'english'}

Test 2: {'text': '', 'language': 'Spanish'}
‚ùå Failed
   Errors: ["Field 'text' cannot be empty"]

Test 3: {'language': 'French'}
‚ùå Failed
   Errors: ['Missing required field: text']

Test 4: {'text': 123, 'language': 'German'}
‚ùå Failed
   Errors: ["Field 'text' must be a string"]

Test 5: {'text': 'Bonjour', 'language': 'Klingon'}
‚ùå Failed
   Errors: ['Unsupported language: Klingon']

==================================================
Example 5: Circuit Breaker Pattern
==================================================

Testing circuit breaker:
‚ùå Request 1: Service temporarily unavailable
‚úÖ Request 2: Processed: Request 2
‚ùå Request 3: Service temporarily unavailable
  Circuit breaker: OPENED after 2 failures
‚ùå Request 4: Service temporarily unavailable
‚ùå Request 5: Circuit breaker is OPEN - service unavailable
‚ùå Request 6: Circuit breaker is OPEN - service unavailable

==================================================
Example 6: Error Aggregation and Reporting
==================================================

Processing items:
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0
  ‚úÖ Processed: Item_0

Error Report:
  Summary: {'total_operations': 11, 'successful': 11, 'failed': 0, 'success_rate': '100.0%'}
  Health Status: healthy
  Recent Errors: 0
  Warnings: 0

==================================================
‚úÖ Best Practices Summary
==================================================

1. Always validate inputs before processing
2. Use try-catch blocks around external calls
3. Implement retry logic for transient failures
4. Have fallback strategies for critical paths
5. Use circuit breakers to prevent cascading failures
6. Aggregate and monitor errors for insights
7. Return structured error responses
8. Log errors for debugging and monitoring
